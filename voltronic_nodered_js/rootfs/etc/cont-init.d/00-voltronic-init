#!/usr/bin/with-contenv bashio
set -e

DATA_DIR="/data/node-red"
FLOW="${DATA_DIR}/flows-voltronic.json"
TEMPLATE="/etc/node-red/flows-template.json"
CREDS_FILE="${DATA_DIR}/flows-voltronic_cred.json"

mkdir -p "$DATA_DIR"

RESET="$(bashio::config 'reset_flows')"

# Lire config add-on
MQTT_HOST="$(bashio::config 'mqtt_host')"
MQTT_PORT="$(bashio::config 'mqtt_port')"
MQTT_USER="$(bashio::config 'mqtt_username')"
MQTT_PASS="$(bashio::config 'mqtt_password')"
MQTT_PREFIX="$(bashio::config 'mqtt_topic_prefix')"
POLL_S="$(bashio::config 'poll_interval_s')"

INV1_PORT="$(bashio::config 'inverters[0].port')"
INV1_BAUD="$(bashio::config 'inverters[0].baudrate')"
INV1_EN="$(bashio::config 'inverters[0].enabled')"

INV2_PORT="$(bashio::config 'inverters[1].port')"
INV2_BAUD="$(bashio::config 'inverters[1].baudrate')"
INV2_EN="$(bashio::config 'inverters[1].enabled')"

INV3_PORT="$(bashio::config 'inverters[2].port')"
INV3_BAUD="$(bashio::config 'inverters[2].baudrate')"
INV3_EN="$(bashio::config 'inverters[2].enabled')"

# Defaults
[ -z "$MQTT_HOST" ] && MQTT_HOST="core-mosquitto"
[ -z "$MQTT_PORT" ] && MQTT_PORT="1883"
[ -z "$MQTT_PREFIX" ] && MQTT_PREFIX="voltronic"
[ -z "$POLL_S" ] && POLL_S="5"

echo "[voltronic] MQTT → ${MQTT_HOST}:${MQTT_PORT} prefix=${MQTT_PREFIX}"
echo "[voltronic] inv1: ${INV1_PORT} baud=${INV1_BAUD} enabled=${INV1_EN}"
echo "[voltronic] inv2: ${INV2_PORT} baud=${INV2_BAUD} enabled=${INV2_EN}"
echo "[voltronic] inv3: ${INV3_PORT} baud=${INV3_BAUD} enabled=${INV3_EN}"
echo "[voltronic] poll_interval_s=${POLL_S}"

# Écrire les credentials (optionnel, mais OK)
if [ -n "$MQTT_USER" ] || [ -n "$MQTT_PASS" ]; then
  cat > "$CREDS_FILE" <<EOF
{
  "mqtt_broker_voltronic": { "user": "$MQTT_USER", "password": "$MQTT_PASS" }
}
EOF
else
  echo "{}" > "$CREDS_FILE"
fi

# Seed si absent ou reset
if [ "$RESET" = "true" ] || [ ! -f "$FLOW" ]; then
  echo "[voltronic] Seeding default flow from template..."
  cp -f "$TEMPLATE" "$FLOW"
else
  echo "[voltronic] Keeping existing flow (patching only config nodes)."
fi

export MQTT_HOST MQTT_PORT MQTT_PREFIX POLL_S
export INV1_PORT INV1_BAUD INV1_EN
export INV2_PORT INV2_BAUD INV2_EN
export INV3_PORT INV3_BAUD INV3_EN

# Patch robuste : si JSON invalide => reseed template et continue (ne crash plus)
node <<'NODE'
const fs = require("fs");

const flowPath = "/data/node-red/flows-voltronic.json";
const templatePath = "/etc/node-red/flows-template.json";

function readJsonSafe(path) {
  const raw = fs.readFileSync(path, "utf8");
  try {
    return { ok: true, json: JSON.parse(raw), raw };
  } catch (e) {
    return { ok: false, err: e, raw };
  }
}

let flowRead = readJsonSafe(flowPath);
if (!flowRead.ok) {
  console.error("[voltronic] ERROR: flows-voltronic.json is not valid JSON.");
  console.error("[voltronic] Reason:", String(flowRead.err));
  console.error("[voltronic] Reseeding from template...");

  const tpl = readJsonSafe(templatePath);
  if (!tpl.ok) {
    console.error("[voltronic] FATAL: flows-template.json is also invalid JSON!");
    console.error("[voltronic] Reason:", String(tpl.err));
    process.exit(1);
  }
  fs.writeFileSync(flowPath, JSON.stringify(tpl.json, null, 2));
  flowRead = { ok: true, json: tpl.json };
}

const flow = flowRead.json;
if (!Array.isArray(flow)) {
  console.error("[voltronic] FATAL: flow root is not an array.");
  process.exit(1);
}

function byId(id){ return flow.find(n => n && n.id === id); }

function setMqtt(){
  const n = byId("mqtt_broker_voltronic");
  if (!n) return;
  n.broker = process.env.MQTT_HOST || "core-mosquitto";
  n.port = String(process.env.MQTT_PORT || "1883");
}

function setSerial(id, port, baud){
  const n = byId(id);
  if (!n) return;
  if (port) n.serialport = String(port);
  if (baud) n.serialbaud = String(baud);
  n.databits = n.databits || "8";
  n.parity = n.parity || "none";
  n.stopbits = n.stopbits || "1";
  n.newline = n.newline || "\\r";
}

function setPoll(id){
  const n = byId(id);
  if (!n) return;
  n.repeat = String(process.env.POLL_S || "5");
}

function setEnabled(changeNodeId, enabledStr){
  const n = byId(changeNodeId);
  if (!n || !Array.isArray(n.rules)) return;
  const enabled = (enabledStr === "true");
  for (const r of n.rules){
    if (r && r.t === "set" && r.p === "enabled"){
      r.to = enabled;
      r.tot = "bool";
    }
  }
}

function setPrefixFn(){
  const n = byId("fn_prefix_replace");
  if (!n) return;
  const prefix = (process.env.MQTT_PREFIX || "voltronic").replace(/\/+$/,"");
  n.func = "msg.topic = (msg.topic||'').replace('__PREFIX__','" + prefix + "');\nreturn msg;";
}

setMqtt();

setSerial("ser_inv1", process.env.INV1_PORT, process.env.INV1_BAUD);
setSerial("ser_inv2", process.env.INV2_PORT, process.env.INV2_BAUD);
setSerial("ser_inv3", process.env.INV3_PORT, process.env.INV3_BAUD);

setPoll("inj_inv1");
setPoll("inj_inv2");
setPoll("inj_inv3");

setEnabled("ch_inv1_qpigs",  process.env.INV1_EN);
setEnabled("ch_inv1_qpigs2", process.env.INV1_EN);
setEnabled("ch_inv2_qpigs",  process.env.INV2_EN);
setEnabled("ch_inv2_qpigs2", process.env.INV2_EN);
setEnabled("ch_inv3_qpigs",  process.env.INV3_EN);
setEnabled("ch_inv3_qpigs2", process.env.INV3_EN);

setPrefixFn();

fs.writeFileSync(flowPath, JSON.stringify(flow, null, 2));
console.log("[voltronic] Patched flow OK");
NODE

chmod 644 "$FLOW" "$CREDS_FILE" || true
echo "[voltronic] Ready. Flow file: $FLOW"
