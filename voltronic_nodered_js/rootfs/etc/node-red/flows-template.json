[
  { "id": "tab_voltronic", "type": "tab", "label": "Voltronic Serial", "disabled": false, "info": "" },

  {
    "id": "mqtt_broker_voltronic",
    "type": "mqtt-broker",
    "name": "MQTT (auto)",
    "broker": "__MQTT_HOST__",
    "port": "__MQTT_PORT__",
    "clientid": "nodered-voltronic",
    "autoConnect": true,
    "usetls": false,
    "protocolVersion": "4",
    "keepalive": "60",
    "cleansession": true
  },

  {
    "id": "fn_crc_frame",
    "type": "function",
    "z": "tab_voltronic",
    "name": "CRC16/XMODEM + Frame",
    "func": "function crc16Xmodem(buf){let crc=0x0000;for(const b of buf){crc^=(b<<8);for(let i=0;i<8;i++){crc=(crc&0x8000)?(((crc<<1)&0xffff)^0x1021):((crc<<1)&0xffff);}}return crc&0xffff;}\nmsg.cmd = msg.cmd || \"\";\nconst payload = Buffer.from(msg.cmd, 'ascii');\nconst crc = crc16Xmodem(payload);\nconst crcBuf = Buffer.alloc(2);\ncrcBuf.writeUInt16BE(crc,0);\nmsg.payload = Buffer.concat([payload, crcBuf, Buffer.from('\\r','ascii')]);\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 240,
    "y": 80,
    "wires": []
  },

  {
    "id": "fn_parse_line",
    "type": "function",
    "z": "tab_voltronic",
    "name": "Parse line '(...)'",
    "func": "let s = msg.payload;\nif (Buffer.isBuffer(s)) s = s.toString('ascii');\ns = (s||\"\").trim();\nif (s.startsWith('(')) s = s.slice(1);\ns = s.replace(/\\r/g,'').trim();\nmsg.line = s;\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 260,
    "y": 140,
    "wires": []
  },

  {
    "id": "fn_merge_payload",
    "type": "function",
    "z": "tab_voltronic",
    "name": "Merge QPIGS/QPIGS2 + publish state",
    "func": "const inv = msg.inv || 'inv';\nconst store = context.get('store') || {};\nstore[inv] = store[inv] || {};\n\n// route by msg.kind\nif (msg.kind === 'QPIGS') {\n  store[inv].qpigs = msg.line;\n}\nif (msg.kind === 'QPIGS2') {\n  // si NAK => ignore\n  if ((msg.line||'').includes('NAK')) store[inv].qpigs2 = null;\n  else store[inv].qpigs2 = msg.line;\n}\ncontext.set('store', store);\n\nconst qpigs = store[inv].qpigs;\nif (!qpigs) return null;\n\nfunction f(x){const v=parseFloat(x);return Number.isFinite(v)?v:null;}\nfunction i(x){const v=parseInt(String(x),10);return Number.isFinite(v)?v:null;}\n\nconst fields = qpigs.split(/\\s+/).filter(Boolean);\nconst payload = { inverter: inv, timestamp: new Date().toISOString() };\n\npayload.grid_v = f(fields[0]);\npayload.grid_hz = f(fields[1]);\npayload.ac_out_v = f(fields[2]);\npayload.ac_out_hz = f(fields[3]);\npayload.apparent_power_va = i(fields[4]);\npayload.active_power_w = i(fields[5]);\npayload.load_pct = i(fields[6]);\npayload.bus_v = i(fields[7]);\npayload.battery_v = f(fields[8]);\npayload.battery_charge_a = i(fields[9]);\npayload.battery_capacity_pct = i(fields[10]);\npayload.heatsink_c = i(fields[11]);\npayload.pv_input_a = i(fields[12]);\npayload.pv_input_v = f(fields[13]);\nif (typeof payload.pv_input_v==='number' && typeof payload.pv_input_a==='number') payload.pv_w_est = Math.round(payload.pv_input_v*payload.pv_input_a*10)/10;\n\n// QPIGS2 (PV2)\nconst qpigs2 = store[inv].qpigs2;\nif (qpigs2) {\n  const f2 = qpigs2.split(/\\s+/).filter(Boolean);\n  payload.pv2_input_a = f(f2[0]);\n  payload.pv2_input_v = f(f2[1]);\n  const p2 = f(f2[2]);\n  payload.pv2_w = Number.isFinite(p2)?p2:null;\n  if (payload.pv2_w==null && typeof payload.pv2_input_v==='number' && typeof payload.pv2_input_a==='number') payload.pv2_w_est = Math.round(payload.pv2_input_v*payload.pv2_input_a*10)/10;\n}\n\nconst pv1 = payload.pv_w_est;\nconst pv2 = payload.pv2_w ?? payload.pv2_w_est;\nif (typeof pv1==='number' || typeof pv2==='number') payload.pv_total_w = Math.round(((pv1||0)+(pv2||0))*10)/10;\n\nmsg.topic = '__PREFIX__/' + inv + '/state';\nmsg.payload = JSON.stringify(payload);\nreturn msg;\n",
    "outputs": 1,
    "noerr": 0,
    "initialize": "context.set('store', {});\n",
    "finalize": "",
    "libs": [],
    "x": 510,
    "y": 360,
    "wires": [["mqtt_out_state"]]
  },

  {
    "id": "mqtt_out_state",
    "type": "mqtt out",
    "z": "tab_voltronic",
    "name": "MQTT state",
    "topic": "",
    "qos": "",
    "retain": "",
    "broker": "mqtt_broker_voltronic",
    "x": 740,
    "y": 360,
    "wires": []
  },

  {
    "id": "fn_prefix_replace",
    "type": "function",
    "z": "tab_voltronic",
    "name": "Set prefix",
    "func": "msg.topic = (msg.topic||'').replace('__PREFIX__','voltronic');\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 520,
    "y": 420,
    "wires": [["mqtt_out_state"]]
  },

  // ===== INV1 =====
  { "id": "inj_inv1", "type": "inject", "z": "tab_voltronic", "name": "inv1 poll", "props": [{"p":"payload"},{"p":"topic","vt":"str"}], "repeat": "__POLL_S__", "once": true, "onceDelay": 2, "topic": "", "payload": "", "payloadType": "date", "x": 120, "y": 220, "wires": [["sw_inv1_enabled"]] },

  { "id": "sw_inv1_enabled", "type": "switch", "z": "tab_voltronic", "name": "inv1 enabled?", "property": "enabled", "propertyType": "msg", "rules": [{"t":"true"}], "checkall": "true", "repair": false, "outputs": 1, "x": 320, "y": 220, "wires": [["ch_inv1_qpigs","ch_inv1_qpigs2"]] },

  { "id": "ch_inv1_qpigs", "type": "change", "z": "tab_voltronic", "name": "QPIGS inv1", "rules": [{"t":"set","p":"cmd","pt":"msg","to":"QPIGS","tot":"str"},{"t":"set","p":"kind","pt":"msg","to":"QPIGS","tot":"str"},{"t":"set","p":"inv","pt":"msg","to":"inv1","tot":"str"},{"t":"set","p":"enabled","pt":"msg","to":"__INV1_EN__","tot":"bool"}], "x": 160, "y": 280, "wires": [["fn_crc_frame","sr_inv1"]] },

  { "id": "ch_inv1_qpigs2", "type": "change", "z": "tab_voltronic", "name": "QPIGS2 inv1", "rules": [{"t":"set","p":"cmd","pt":"msg","to":"QPIGS2","tot":"str"},{"t":"set","p":"kind","pt":"msg","to":"QPIGS2","tot":"str"},{"t":"set","p":"inv","pt":"msg","to":"inv1","tot":"str"},{"t":"set","p":"enabled","pt":"msg","to":"__INV1_EN__","tot":"bool"}], "x": 170, "y": 320, "wires": [["fn_crc_frame","sr_inv1"]] },

  {
    "id": "sr_inv1",
    "type": "serial request",
    "z": "tab_voltronic",
    "name": "Serial request inv1",
    "serial": "ser_inv1",
    "x": 470,
    "y": 300,
    "wires": [["fn_parse_line","fn_merge_payload","fn_prefix_replace"]]
  },

  {
    "id": "ser_inv1",
    "type": "serial-port",
    "serialport": "__INV1_PORT__",
    "serialbaud": "__INV1_BAUD__",
    "databits": "8",
    "parity": "none",
    "stopbits": "1",
    "newline": "\\r",
    "bin": "bin",
    "out": "bin",
    "addchar": false,
    "responsetimeout": "1000"
  }
]
